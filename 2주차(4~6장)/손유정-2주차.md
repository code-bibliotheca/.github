# Clean Code 4-6장

## 4. 주석

### 주석은 나쁜 코드를 보완하지 못한다

주석으로 코드의 불완전한 부분을 보완하는 것보다 코드 자체를 개선하는 것이 좋다. 코드 자체로 의도를 명확하게 전달할 수 있어야 한다.

### 코드로 의도를 표현하라!

좋은 코드는 주석이 필요 없다. 주석은 코드를 개선할 수 있는 잠재적인 기회를 제공하지 않으며, 주석을 유지하는 것은 코드를 유지하는 것보다 어렵다.

주석은 코드에 부가적인 정보를 제공하기 위해 사용되어야 한다. 설명이 필요한 경우, 주석을 최소화하고 자체 설명력 강한 변수 이름, 함수 이름 등을 사용해야 한다.

⇒ 대다수의 주석은 단순히 코드를 설명하는 것이 아니라 잘못된 코드를 복구하는 데 사용되어야 한다. 따라서 주석이 필요한 경우, 왜 코드가 그런 방식으로 동작하는지를 설명하는 대신 코드를 개선하도록 노력해야 한다.

### 좋은 주석

- **법적인 주석**
- **정보를 제공하는 주석**
- **의도를 설명하는 주석**
- **의미를 명료하게 밝히는 주석**
- **결과를 경고하는 주석**
- **TODO 주석**
- **중요성을 강조하는 주석**
- **공개 API에서 Javadocs**

### 나쁜 주석

- **주절거리는 주석**
- **같은 이야기를 중복하는 주석**
- **오해할 여지가 있는 주석**
- **의무적으로 다는 주석**
- **이력을 기록하는 주석**
- **있으나 마나 한 주석**
- **무서운 잡음**
- **함수나 변수로 표현할 수 있다면 주석을 달지 마라**
- **위치를 표시하는 주석**
- **닫는 괄호에 다는 주석**
- **공로를 돌리거나 저자를 표시하는 주석**
- **주석으로 처리한 코드**
- **HTML 주석**
- **전역 정보**
- **너무 많은 정보**
- **모호한 관계**
- **함수 헤더**
- **비공개 코드에서 Javadocs**

⇒ 무작정 자세하게 주석을 적기만 하면 보는 사람이 이해하기 쉬울거라고 생각했었는데 코드를 개선하는 것이 더 중요하다는 것을 알게 되었다.

## 5. 형식 맞추기

### 형식을 맞추는 목적

오늘 구현한 기능의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다. 원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다.

⇒ ‘돌아가는 코드’만 생각했던 내 자신을 반성하게 되었다.ㅜㅜ

### 적절한 행 길이를 유지하라

일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.

### 신문 기사처럼 작성하라

이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다. 아래로 내려갈수록 의도를 세세하게 묘사한다.

### 개념은 빈 행으로 분리하라

거의 모든 코드는 왼쪽에서 오른쪽으로 그리고 위에서 아래로 읽힌다. 각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다. 생각 사이는 빈 행을 넣어 분리해야 마땅하다.

### 세로 밀집도

서로 밀접한 코드 행은 세로로 가까이 놓여야 한다.

### 수직 거리

protected 변수를 피해야 하는 이유.

타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다.

같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다.

**변수 선언**. 변수는 사용하는 위치에 최대한 가까이 선언한다.

**지역 변수**는 각 함수 맨 처음에 선언한다.

**인스턴스 변수**는 클래스 맨 처음에 선언한다.

변수 간에 세로로 거리를 두지 않는다.

**종속 함수**. 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.

가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.

**개념적 유사성.** 친화도가 높을수록 코드를 가까이 배치한다.

### 세로 순서

일반적으로 함수 호출 종속성은 아래 방향으로 유지한다. 다시 말해 호출되는 함수를 호출하는 함수보다 나중에 배치한다.

### 가로 형식 맞추기

프로그래머는 명백하게 짧은 행을 선호한다.

### 가로 공백과 밀집도

가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.

### 가로 정렬

하지 않는다!

### 들여쓰기

들여쓰기한 파일은 구조가 한눈에 들어온다. 변수, 생성자 함수, 접근자 함수, 메서드가 금방 보인다.

### 가짜 범위

### 팀 규칙

프로그래머라면 각자 선호하는 규칙이 있다. 하지만 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.

팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 보인다.

### 6. 객체와 자료 구조

### 자료 추상화(객체와 자료구조 사이에 벌어진 차이)

```java
// 6-1 구체적인 Point 클래스
public class Point {
	public double x;
	public double y;
}
```

- 직계좌표계를 사용한다.
- 개별적으로 좌표값을 읽고 설정하게 강제한다.
- 구현을 노출한다.
- 변수를 private로 선언하더라도 각 값마다 조회 함수와 설정 함수를 제공한다면 구현을 외부로 노출하는 셈이다.

```java
// 6-2 추상적인 Point 클래스
public interface Point {
	double getX();
	double getY();
	void setCartesian( double x, double y);
	double getR();
	double getTheta();
	void setPolar(double r, double theta);
}
```

- 직계좌표계를 사용하는지 극 좌표계를 사용하는지 알 길이 없다. 둘 다 아닐지도 모른다.
- 그럼에도 불구하고 인터페이스는 자료 구조를 명백하게 표현한다.

변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지 않는다.

구현을 감추려면 추상화가 필요하다.

그저 형식 논리에 치우쳐 조회 함수와 설정함수로 변수를 다룬다고 클래스가 되지는 않는다.

⇒ **추상 인터페이스를 제공해 사용자가 구현을 모른채 자료의 핵심을 조작할 수 있어야** 진정한 의미의 클래스다.

```java
// 6-3 구체적인 Vehicle 클래스
public interface Vehicle {
	double getFuelTankCapacityInGallons();
	double getGellonsOfGasoline();
}
```

```java
// 6-4 추상적인 Vehicle 클래스
public interface Vehicle {
	double getPercentFuelRemaining();
}
```

- 6-1 → 6-2 → 6-3 → 6-4 순으로 좋음
- 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.
- 인터페이스나 조회/설정 함수만으로는 추상화가 이뤄지지 않는다.
- 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.
- 아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.

### 자료/객체 비대칭

객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.

자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.

두 정의는 본질적으로 상반되고 두 개념은 사실상 정반대다.

```java
// 6-5 절차적인 도형
public class Square {
	public Point topLeft;
	public double side;
}

public classs Rectangle {
	public Point topLeft;
	public double height;
	public double width;
}

public classs Circle {
	public Point center;
	public double radius;
}

public classs Geoetry {
	public final double PI = 3.141592653589793;

	public double area(Object shape) throws NoSuchShapeException
{
		if (shape instanceof Square) {
			Square s = (Square)shape;
				return s.side * s.side;
		}
		else if (shape instanceof Rectangle) {
			Rectangle r = (Rectangle)shape;
				return r.height * r.width;
		}
		else if (shape instanceof Circle) {
			Circle = (Circle)shape;
				return PI * c.radius * c.radius;
		}
				throw new NoSuchShapeException();
	}
}
```

```java
// 6-6 다형적인 도형
public class Square implements Shape {
	private Point topLeft;
	private double side;

	public double area() {
		return side*side;
	}
}

public class Rectangle implements Shape {
	private Point topLeft;
	private double height;
	private double width;

	public double area() {
		return height * width;
	}
}

public class Circle implements Shape {
	private Point center;
	private double radius;
	private final double PI = 3.141592653589793;

	public double area() {
		return PI * radius * radius;
}
}
```

- 6-5, 6-6은 상호 보완적인 특질이 있다.
- 객체와 자료구조는 근본적으로 양분된다.

**자료구조**는 자료를 그대로 공개하고 함수를 제공하지 않으며, 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하는 것이 비교적 쉽다. 그러나 새로운 자료 구조를 추가하는 것은 어렵다.

**객체**는 추상화를 통해 자료를 숨기고 함수만 공개하는 방식으로 작동한다. 기존 함수를 변경하지 않으면서 새 클래스를 추가하는 것이 쉽지만, 새로운 함수를 추가하기는 어렵다. 이 경우 모든 클래스를 수정해야 한다.

복잡한 시스템에서는 때로는 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 있습니다. 이때는 클래스와 객체 지향 기법이 가장 적합합니다. 반면에 새로운 함수가 필요한 경우에는 절차적인 코드와 자료구조가 더 적합합니다.

따라서 요약하자면, 자료구조와 객체 지향 코드는 서로 보완적이며, 어떤 방식을 선택할지는 새로운 자료 타입이 필요한지 아니면 새로운 함수가 필요한지에 따라 결정해야 합니다.

### 디미터 법칙

디멘터 법칙은 잘 알려진 휴리스틱으로 모듈은 자신이 조작하느 객체의 속사정을 몰라야 한다는 법칙이다. 앞 절에서 봤듯이, 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안 된다는 의미다. 그러면 내부 구조를 (숨기지 않고) 노출하는 셈이기 때문이다.

좀 더 정확히 표현하자면 , 디미터 법칙은 ‘클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다’고 주장한다.

- 클래스 C
- f가 생성한 객체
- f 인수로 넘어온 객체
- c 인스턴스 변수에 저장된 객체

하지만 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안 된다. 다시 말해, 낯선 사람은 경계하고 친구랑만 놀라는 의미다.

다음 코드는 다른 법칙을 제쳐두고서라도 디미터 법칙을 어기는 듯이 보인다. getOptions() 함수가 반환하는 객체의 getScratchDir() 함수를 호출한 후 getScratchDir() 함수가 반환하는 객체의 getAbsolutePath() 함수를 호출하기 때문이다.

final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

### 기차 충돌

위 코드 예제는 디미터 법칙을 위반하는지 여부는 **`ctxt`**, **`Options`**, **`ScratchDir`**이 객체인지 아니면 자료 구조인지에 달려있다.

- 객체인 경우: 위 코드는 객체의 내부 구조를 탐색하므로 디미터 법칙을 위반한다. 객체는 자신의 내부 구조를 숨기는 것이 좋다.
- 자료 구조인 경우: 자료 구조는 단순히 공개 변수만 포함하므로 디미터 법칙이 적용되지 않는다.

그러나 조회 함수를 사용하는 방식은 혼란을 일으킬 수 있으므로, 코드를 단순화하고 디미터 법칙을 고려할 필요가 없도록 구현하는 것이 좋다. 즉, 아래와 같이 코드를 개선할 수 있다.

```java
final String outputDir = ctxt.options.scratchDir.absolutePath;
```

이렇게 코드를 개선하면 디미터 법칙을 위반하지 않고도 목적을 달성할 수 있다. 단순한 자료 구조에는 조회 함수와 설정 함수를 정의하는 프레임워크와 표준이 있을 수 있지만, 필요에 따라 적절히 활용하면 된다.

### 잡종 구조

잡종 구조는 객체지향 프로그래밍과 절차적 프로그래밍의 특징을 혼합한 구조를 말한다. 이는 객체 지향 프로그래밍에서 객체들이 상태와 행동을 함께 갖는 것과 달리, 잡종 구조에서는 함수와 데이터를 별개로 다루는 경향이 있다.

이런 혼란으로 말미암아 때때로 절반은 객체, 절반은 자료 구조인 잡종 구조가 나온다. 잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 조회/설정 함수도 있다. 공개 조회/설정 함수는 비공개 변수를 그대로 노출한다.

덕택에 다른 함수가 절차적인 프로그래밍의 자료 구조 접근 방식처럼 비공개 변수를 사용하고픈 유혹에 빠지기 십상이다.

이런 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다. 양족 세상에서 단점만 모아놓은 구조다. 그러므로 잡종 구조는 되도록 피하는 편이 좋다. 프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해 어중간하게 내놓은 설계에 불과하다.

요약한다면, 혼란을 피하기 위해 잡종 구조는 피하는 것이 좋다.

### 구조체 감추기

위 코드에서 **`ctxt`**, **`options`**, **`srcatchDir`**이 실제 객체라면, 이 객체들의 내부 구조를 숨겨야 하는데, 임시 디렉터리의 절대 경로를 어떻게 얻을 수 있을까?.

여러 가지 방법이 있을 수 있지만, 첫 번째 방법은 **`ctxt`** 객체가 **`getAbsolutePathOfScratchDirectoryOption()`** 메서드를 제공하여 절대 경로를 반환하는 방법이다. 하지만 이 경우에는 **`ctxt`** 객체에 너무 많은 공개 메서드가 존재하게 되어 객체의 내부 구조를 노출시키게 될 수 있다.

두 번째 방법은 **`ctx`** 객체의 **`getScratchDirectoryOption()`** 메서드가 객체 대신 데이터 구조를 반환한다고 가정하는 것이다. 이 경우에는 해당 메서드로부터 반환된 데이터 구조에서 절대 경로를 얻을 수 있을 것이다.

하지만 이러한 방법들은 적합하지 않을 수 있다. 객체의 내부 구조를 노출시키는 것은 좋지 않은 설계다. 또한, 왜 임시 디렉터리의 절대 경로가 필요한지, 어떤 목적으로 사용되는지에 따라 다른 해결 방법이 있을 수 있다.

더 쉽게 요약하면, 객체의 내부 구조를 숨기는 것이 좋은 설계 원칙이다. 따라서 다른 방법을 고려하여 객체의 내부 구조를 노출시키지 않고 임시 디렉터리의 절대 경로를 얻을 수 있는 방법을 찾아보는 것이 좋다.

### 자료 전달 객체

자료 구조체는 **공개 변수만 가지고 함수가 없는 클래스**로서, 때로는 "**자료 전달 객체**"라고 불립니다. 이러한 자료 구조체를 DTO(Data Transfer Object)라고 합니다. DTO는 매우 유용한 구조체로, 데이터베이스와의 통신이나 소켓에서 받은 메시지의 구문을 분석하는 등의 작업에 유용합니다. 일반적으로 DTO는 **데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 과정**에서 첫 번째로 사용되는 구조체입니다.

### 활성 레코드

활성 레코드는 **특수한 형태의 DTO(데이터 전송 객체)**다. 이는 **공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조**를 말한다. 일반적으로는 데이터베이스 테이블이나 다른 소스에서 직접 변환된 데이터의 결과다.

그러나 많은 개발자들이 활성 레코드에 비즈니스 규칙 메서드를 추가하여 이러한 자료 구조를 객체로 취급하는 경향이 있다. 이러한 접근은 바람직하지 않다. 왜냐하면 그렇게 되면 자료 구조도 아니고 객체도 아닌 혼합된 구조가 만들어지기 때문이다.

해결책은 간단하다. **활성 레코드는 자료 구조로 취급하고, 비즈니스 규칙을 담은 객체는 따로 생성한다.** 이 경우 내부 자료는 활성 레코드의 인스턴스일 가능성이 높다.

요약하자면, 활성 레코드는 자료 구조로 취급되어야 하며, 비즈니스 규칙을 담은 객체는 활성 레코드의 인스턴스와 분리하여 사용하는 것이 좋다.

### 결론

**객체 지향 프로그래밍**에서는 객체가 동작을 공개하고 자료를 숨기는 반면, **자료 구조**는 동작 없이 자료를 노출한다. 따라서 **객체 지향 프로그래밍**은 새로운 객체 타입을 추가하기 쉬우며, 기존 객체에 새 동작을 추가하기는 어렵다. 반면에 **자료 구조**는 새로운 동작을 추가하기 쉽지만, 기존 함수에 새 자료 구조를 추가하기는 어렵다.

따라서 **시스템에 새로운 자료 타입을 추가하는 유연성이 필요한 경우**에는 **객체 지향 프로그래밍**이 더 적합하며, **새로운 동작을 추가하는 유연성이 필요한 경우**에는 **자료 구조와 절차적인 코드**가 더 적합하다. 좋은 소프트웨어 개발자는 이 차이를 이해하고, 직면한 문제에 최적의 해결책을 선택하기 위해 편견 없이 접근한다.

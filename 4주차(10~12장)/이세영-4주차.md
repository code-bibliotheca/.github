### 10장 - 클래스

<br>

코드를 올바르게 작성하고, 함수를 올바르게 구현하더라도 높은 차원의 단계를 신경 써야 클린한 코드가 될 수 있다! 그러기 위해서 필요한 것이 클. 래. 스~~~~~

클래스는 (자바기준) 아래의 추상화 단계를 거친다

- 변수 목록 (정적 static, 공개 public, 상수 → 정적 비공개 private → 비공개 인스턴스 변수 순으로 나열)
- 공개 함수 → 비공개 함수는 자신을 호출하는 공개함수 직후에 나열

<br>

**[단일 책임 원칙]**

클래스는 하나의 책임만을 가지게 만들어야 한다!

- **클래스를 변경해야 할 이유**(책임)가 **단 한 가지여야 한다**는 것! (관심사의 분리와 같은 것인가?)

- 즉, 클린한 코드를 위해서는 하나의 서랍에 기능을 다 때려 넣는 것이 아닌 작은 클래스들을 엮어서 만들어야 함

> 이유 : 여러 기능이 있는 하나의 단위는, 무언가 변경이 필요할 때 개발자가 봐야 할 (현재 변경에 필요 없는,) 불필요한 내용이 많아짐! 작게 만들어야 그것에 해당하는 부분만 보고 개발할 수 있어 효율적!

- 시스템이 커질 때 필요한 부분을 쉽게 찾을 수 있게 해주는 용도도 있음

* 공감했던? 아차 싶었던 부분: 단일 책임 클래스가 많아지면 큰 그림을 이해하기 위해 여러 클래스들을 들여다보며 파악하는 것이 더 안 좋은 것이 아닌가, 그것이 좋고 깨끗한 코드인가 하고 나도 생각했었기에.. 생각을 바꾸게 하는 부분이었다
  - 어차피 큰 하나의 단위이던, 작은 여러개의 단위이던 익혀야 할 코드의 수는 비슷하다! 근데 **여러 개의 기능이 담긴 큰 단위는 추후에 프로그램이 커졌을 때 해당하는 부분을 찾기도 어렵고, 한 부분을 수정하려고 해도 불필요한 부분까지 다시 파악해야 해서 좋지 않은 코드다!**

**[응집도]**

메서드가 변수를 많이 사용할수록 응집도가 높다는 의미

- 공감했던 부분: 코드를 리팩토링하는 예제에서, 리팩토링하는 과정.
  - 왜? 현재 코드 리팩토링을 할 때 원래 됐던 기능이 안 되는 경우들이 발생, 그래서 현재는 큰 틀의 변경 내용에 대한 버전관리(무식하게 손으로…) 해왔음…
  - 근데 이 책에선 원래의 코드가 동작해야 하는 내용의 테스트 코드로 작성해 놓고, 조금씩 코드를 변경해 가면서 그때그때 동작을 검증함
  - 아… 이래서 테스트 코드가 필요하다 했었지!!!!! 아!!! 공감이라기보단 깨달음…!
  - 번외로, 리팩토링 시 하나의 책임을 갖는 함수(나 클래스) 단위로 쪼개기! 하지만 그것이 아직은 어렵...
- 기억하고 싶은 부분
  - p188 마지막 문단. 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다. 이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다(OOP 중 OCP\_개방 폐쇄 원칙에 해당하는 내용)
- `변경으로부터 격리`라는 부분은 이해가 잘 안됨.. 역전 의존 원칙(DIP).. 컨트롤할 수 없는 사이드 이펙트와 관련된 것을 줄이라는 건가….?

### 11장 시스템

<br>

- 맘에 드는 문단 (**확장** 부분)

  ‘처음부터 올바르게’ 시스템을 만들 수는 없다. 당장은 주어진 사용자 스토리에 맞춰 시스템을 구현하되, 추후에 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. ~~이것이 애자일한 방식이고???~~ TDD, 리팩터링을 통해 코드 수준에서 조정과 확장하기 쉽게 만들어야 함!

  그니까.. 시스템은 건축과 같고.. 관심사의 분리가 잘 되어야 하고, 잘 분리하기 위한 여러 가지 관점이나 메커니즘이 있으니 원하는 방향성의 것을 취해 분리한다

  추후에 조금 더 쉽게 확장할 수 있게 최대한 추상화를 잘 해야 된다..?,

  ~~내용이 너무 이해가 안됨.. 다시 읽어보고, 글을 좀 찾아봐야겠음~~

### 12장 창발성

<br>

클린 코드(? 설계?)를 위한 4가지 규칙

1. 모든 **테스트**를 실행한다.

   - 시스템이 의도한 대로 돌아가는지 검증하기 위해

     (→ 책을 보다 보니까 이런 논리?, 테스트를 해야 한다는 경험들이 쌓여서 관심사의 분리, 단일 책임원칙과 같은 것들이 나온듯싶다)

   - 테스트가 가능한 시스템을 만들기 위한 노력들이 더 나은 설계를 만듦(결과론적으로 테스트를 위해 결합도를 낮추고, 응집력은 높이게 됨)

2. **중복**을 없앤다
   - 중복은 추가 작업, 추가 위험, 불필요한 복잡도!
   - 중복을 없애 재사용할 수 있게 하자
3. 프로그래머 **의도**를 표현한다
   - 그래야 코드가 명백해지고, 그래야 다른 사람이 내가 짠 코드를 이해하기 쉬워진다. 그래야(결론) 결함이 줄고, 유지보수 비용이 적게 든다!
     - 기능과 매칭되는 **좋은 이름 짓기**
     - **함수나 클래스의 크기를 줄여**야 표현하기 쉽다(+구현, 이해까지도 쉬워진다!)
     - 표준 패턴을 이용했다면 명시해 주기
     - **단위 테스트 꼼꼼하게** 작성해서 내가 원한 해당 기능에 대한 설명이 될 수 있게
     - 다른 사람을 위해 최대한 읽기 쉽게! 충분히 고민하며 만들자!!! 그게 내가 될 수 있다!!!!!!
4. 클래스와 메서드 수를 **가.능.한** 최소로 줄인다.
   - 하지만 너무 무분별하면 안 돼!
   - 이 규칙은 일단 중요도가 가장 낮고(위에 세가지에 더 초점을 맞추는 것이 중요!!!), 경험이 좀 필요할 것 같다. 얼마만큼이 너무 무분별하게 쪼개진 거고, 적절하게 쪼개진 것인지

그래서 결론. **리팩터링**

- 응집도를 높이고, 결합도를 낮추고, 관심사를 분리, 모듈화, 함수와 클래스의 크기를 줄이고, 변수명을 변경하고 등등의 작업을 위 2~4번째 규칙을 적용해 리팩터링을 진행하게 된다.
